"""Neuroevolution fitting."""

from dataclasses import dataclass
from typing import Annotated as An
from typing import Any

import wandb
from hydra.utils import instantiate
from omegaconf import MISSING
from wandb.util import generate_id

from cneuromax.fitting import BaseFittingHydraConfig
from cneuromax.fitting.neuroevolution.agent.batched import BaseBatchedAgents
from cneuromax.fitting.neuroevolution.agent.singular import BaseSingularAgent
from cneuromax.fitting.neuroevolution.space import BaseSpace
from cneuromax.fitting.neuroevolution.utils import (
    compute_pickled_agents_sizes,
    compute_save_points,
    compute_start_time_and_seeds,
    exchange_agents,
    initialize_common_variables,
    initialize_gpu_comm,
    load_state,
    run_evaluation_cpu,
    run_evaluation_gpu,
    run_mutation,
    run_selection,
    save_state,
    update_exchange_and_mutate_info,
)
from cneuromax.utils.annotations import ge
from cneuromax.utils.mpi import retrieve_mpi_variables


@dataclass
class NeuroevolutionFittingHydraConfig(BaseFittingHydraConfig):
    """.

    Attributes:
        space: Implicit (generated by :mod:`hydra-zen`)\
            `SpaceHydraConfig` instance.
        agent: Implicit (generated by :mod:`hydra-zen`)\
            `AgentHydraConfig` instance.
        wandb_entity: :mod:`wandb` entity (username or team name)\
            to use for logging. `None` means no logging.
        agents_per_task: Number of agents per task (`num_tasks` =\
            `num_nodes` x `tasks_per_node`).
        prev_num_gens: Number of generations from a previous experiment\
            to load.
        total_num_gens: Number of generations to run the experiment for\
            (including the previous number of generations).
        save_interval: Number of generations between each save point.\
            `0` means no save point except for the last generation.
        save_first_gen: Whether to save the state of the experiment\
            after the first generation (usually for plotting purposes).
        pop_merge: Whether to merge both generator and discriminator\
            populations into a single population. This means that each\
            agent will be evaluated on both its generative and\
            discriminative abilities.
        env_transfer: Whether a parent agent's environment state\
            (position, velocity, ...) is transferred to its children.
        fit_transfer: Whether a parent agent's fitness is transferred\
            to its children.
        mem_transfer: Whether a parent agent's hidden state is\
            transferred to its children.
        eval_num_steps: Number of environment steps to run each agent\
            for during evaluation. `0` means that the agent will run\
            until the environment terminates (`eval_num_steps = 0` is\
            not supported for `env_transfer = True`).

    """

    space: Any = MISSING
    agent: Any = MISSING
    wandb_entity: str | None = None
    agents_per_task: An[int, ge(1)] = 1
    prev_num_gens: An[int, ge(0)] = 0
    total_num_gens: An[int, ge(1)] = 10
    save_interval: An[int, ge(0)] = 0
    save_first_gen: bool = False
    pop_merge: bool = False
    env_transfer: bool = False
    fit_transfer: bool = False
    mem_transfer: bool = False
    eval_num_steps: An[int, ge(0)] = 0


def fit(config: NeuroevolutionFittingHydraConfig) -> None:
    """Fitting function for Neuroevolution algorithms.

    This function is the main entry point of the Neuroevolution module.
    It acts as an interface between Hydra (configuration + launcher +
    sweeper), Spaces, Agents and MPI resource scheduling for
    Neuroevolution algorithms.

    Note that this function and all of its sub-functions will be called
    by `num_nodes * tasks_per_node` MPI processes/tasks. These two
    variables are set in the Hydra launcher configuration.

    Args:
        config: The run's Hydra configuration, see\
            :class:`NeuroevolutionFittingHydraConfig`.
    """
    comm, _, _ = retrieve_mpi_variables()
    space: BaseSpace = instantiate(config=config.space)
    validate_config(config=config, num_pops=space.num_pops)
    save_points = compute_save_points(
        prev_num_gens=config.prev_num_gens,
        total_num_gens=config.total_num_gens,
        save_interval=config.save_interval,
        save_first_gen=config.save_first_gen,
    )
    (
        pop_size,
        agents_batch,
        generation_results,
        generation_results_batch,
        exchange_and_mutate_info,
        exchange_and_mutate_info_batch,
        total_num_env_steps,
    ) = initialize_common_variables(
        agents_per_task=config.agents_per_task,
        num_pops=space.num_pops,
    )
    if space.evaluates_on_gpu:
        ith_gpu_comm = initialize_gpu_comm()
    if config.prev_num_gens > 0:
        (
            agents_batch,
            generation_results,
            total_num_env_steps,
        ) = load_state(
            prev_num_gens=config.prev_num_gens,
            len_agents_batch=len(agents_batch),
        )
    setup_wandb(entity=config.wandb_entity)
    for curr_gen in range(config.prev_num_gens, config.total_num_gens):
        start_time, seeds = compute_start_time_and_seeds(
            generation_results=generation_results,
            curr_gen=curr_gen,
            num_pops=space.num_pops,
            pop_size=pop_size,
            pop_merge=config.pop_merge,
        )
        if curr_gen > 0:
            update_exchange_and_mutate_info(
                num_pops=space.num_pops,
                pop_size=pop_size,
                exchange_and_mutate_info=exchange_and_mutate_info,
                generation_results=generation_results,
                seeds=seeds,
            )
            comm.Scatter(
                sendbuf=exchange_and_mutate_info,
                recvbuf=exchange_and_mutate_info_batch,
            )
            exchange_agents(
                num_pops=space.num_pops,
                pop_size=pop_size,
                agents_batch=agents_batch,
                exchange_and_mutate_info_batch=exchange_and_mutate_info_batch,
            )
        run_mutation(
            agents_batch=agents_batch,
            exchange_and_mutate_info_batch=exchange_and_mutate_info_batch,
            num_pops=space.num_pops,
        )
        fitnesses_and_num_env_steps_batch = (
            (
                run_evaluation_gpu(
                    ith_gpu_comm=ith_gpu_comm,
                    agents_batch=agents_batch,
                    space=space,
                    curr_gen=curr_gen,
                    transfer=config.env_transfer
                    or config.fit_transfer
                    or config.mem_transfer,
                )
            )
            if space.evaluates_on_gpu
            else run_evaluation_cpu(
                agents_batch=agents_batch,
                space=space,
                curr_gen=curr_gen,
            )
        )
        generation_results_batch[:, :, 0:2] = fitnesses_and_num_env_steps_batch
        compute_pickled_agents_sizes(
            generation_results_batch=generation_results_batch,
            agents_batch=agents_batch,
            num_pops=space.num_pops,
        )
        # Primary process gathers fitnesses, number of environment steps
        # and pickled agent sizes
        comm.Gather(
            sendbuf=generation_results_batch,
            recvbuf=generation_results,
        )
        total_num_env_steps = run_selection(
            generation_results=generation_results,
            total_num_env_steps=total_num_env_steps,
            curr_gen=curr_gen,
            start_time=start_time,
            pop_merge=config.pop_merge,
        )
        # State saving.
        if curr_gen + 1 in save_points:
            save_state(
                agents_batch=agents_batch,
                generation_results=generation_results,
                total_num_env_steps=total_num_env_steps,
                curr_gen=curr_gen,
            )
    wandb.finish()


def validate_config(
    config: NeuroevolutionFittingHydraConfig,
    num_pops: int,
) -> None:
    """Makes sure that the configuration is valid.

    TODO: evaluates_on_gpu & gpus_per_node

    Args:
        config: The run's Hydra configuration, see\
            :class:`NeuroevolutionFittingHydraConfig`.
        num_pops: See\
            :meth:`cneuromax.fitting.neuroevolution.space.BaseSpace.num_pops`.
    """
    if config.eval_num_steps == 0 and config.env_transfer:
        error_msg = "`env_transfer = True` requires `eval_num_steps > 0`."
        raise ValueError(error_msg)
    if (
        config.total_num_gens - config.prev_num_gens
    ) % config.save_interval != 0:
        error_msg = (
            "`save_interval` must be a multiple of "
            "`total_num_gens - prev_num_gens`."
        )
        raise ValueError(error_msg)
    if config.pop_merge and num_pops != 2:  # noqa: PLR2004
        error_msg = "`pop_merge = True` requires `num_pops = 2`."
        raise ValueError(error_msg)


def setup_wandb(entity: None | str) -> None:
    """Reads the W&B key, logs in, creates a group and initializes.

    Args:
        entity: Name of the account or team to use for the current run.
    """
    if not entity:
        return
    comm, rank, _ = retrieve_mpi_variables()
    wandb_group_id = generate_id() if rank == 0 else None
    wandb_group_id = comm.bcast(wandb_group_id)
    wandb.init(entity=entity, group=wandb_group_id)
